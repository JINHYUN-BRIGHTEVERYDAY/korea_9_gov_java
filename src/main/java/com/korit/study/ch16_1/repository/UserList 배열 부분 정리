 /*
    *
    * 좋아 — 아주 잘 왔어. 아래에서 `UserList` 파일을 **맨 위부터 한 줄씩 / 한 블록씩** 논리적으로 풀어서 설명해줄게. 가능한 한 핵심 이유(왜 이렇게 짰는지)와 잠재적 문제점, 더 나은 대안(리팩토링 코드 포함)까지 같이 보여줄게. 부담없이 쭉 읽어봐.

---

# 파일 전체 목적 (한 문장)

이 클래스는 데이터베이스 없이 메모리(배열)로 **User 엔티티들을 저장하고 조회하는 간이 저장소(Repository)** 역할을 한다. 학습용으로 `ArrayList` 같은 컬렉션을 직접 구현해보는 패턴이다.

---

# 코드 전체 (주요 부분별 설명)

```java
package com.korit.study.ch16_1.repository;

import com.korit.study.ch16_1.entity.User;
```

* `package` / `import`: 클래스의 위치와 `User` 엔티티를 사용하겠다는 선언. 기본 문법이다.

---

```java
// Repository 단계, 그러므로 Entity에 접근이 잦은 파트
public class UserList {
```

* `UserList` 클래스 선언. 주석이 말해주듯 repository 계층을 흉내낸 자바 클래스다.

---

```java
    // User 엔티티에 담아두었던 DB -> 배열로 만들기
    public User[] users;
```

* `User[] users;` : `User` 객체들을 담는 배열 변수.
* **중요(권장 변경)**: `public`으로 노출되어 있다. 외부에서 직접 수정될 수 있어 캡슐화(정보 은닉)가 깨진다. 보통은 `private`으로 두고 getter/setter로 접근하게 한다.

  * 이유: 외부에서 배열을 마음대로 바꾸면 클래스 내부 상태가 예측 불가능해진다.

---

```java
    // UserList 생성하는 생성자
    public UserList() {
        // this.users = users;
        this.users = new User[0];
    }
```

* 생성자: `UserList` 인스턴스를 만들면 `users`를 길이 0인 배열로 초기화한다.
* 의미: 처음엔 저장된 유저가 없는 상태를 명확히 표현하기 위해 빈 배열을 만든다.
* 왜 빈 배열인가? Java 배열은 크기가 고정이므로, 처음에 `null` 대신 길이 0 배열로 두면 나중에 `for`문에서 `NullPointerException`을 피할 수 있다.

---

```java
    // User배열 조회하는 메서드
    public User[] findAll() {
        return users;
    }
```

* `findAll()` : 현재 저장된 모든 `User` 배열을 그대로 반환한다.
* 주의: 배열을 직접 반환하면 호출자가 배열 내용을 바꿀 수 있다(예: `returnedArray[0] = null`). 안전하려면 **복사본을 반환**하거나 `List`를 반환하는 편이 낫다.

---

```java
    // UserId 생성하기
    public int generatedUserId() {
        // 새로운 아이디를 1이라고 두고
        int newId = 1;
        // users 배열의 길이가 전혀 없으면 그냥 새로운 아이디를 반환하고
        if (users.length == 0) {
            return newId;
        }
        // 그렇지 않다면 -> ★
        return users[users.length - 1].getId() + 1;
        // getId는 User에서 private로 접근 불가능한 멤버변수를 위하여
        // getter로 만들었음
    }
```

* 목적: 추가될 새 사용자의 `id`를 생성(할당)한다.
* 동작:

  * 배열이 비어 있으면 `1` 반환.
  * 배열에 요소가 있으면 **마지막 요소의 id 값**을 가져와 `+1` 한다.
* 논리적 가정: 배열에 들어간 순서가 **항상 id 오름차순**이라는 가정에 의존한다. (즉, 마지막 요소가 가장 큰 id를 가진다)
* 문제점 / 엣지케이스:

  * 삭제가 발생하면 마지막 요소가 최고 id가 아닐 수 있다 → id 충돌 가능.
  * 동시성 환경(멀티스레드)에서는 두 스레드가 동일 id를 받는 문제.
* 개선안:

  * `private int nextId = 1;` 필드를 두고 `generatedUserId()`는 `return nextId++`처럼 관리하는 것이 안전하다.
  * DB가 있으면 보통 DB 시퀀스/오토인크리먼트 사용.

---

```java
    // User 추가하기 -> ★
    public void add(User user) {
        // 임시 사용자
        User[] temp = new User[users.length + 1];

        // 반복하여 User 추가하기
        for (int i = 0; i < users.length; i++) {
            temp[i] = users[i];
        }
        temp[temp.length - 1] = user;
        users = temp;
    }
```

* 목적: 배열에 `user`를 추가한다.
* 동작:

  1. 기존 배열보다 길이 1 큰 `temp` 배열을 새로 만든다.
  2. 기존 `users`의 모든 요소를 `temp`에 복사한다.
  3. `temp`의 마지막 칸에 새 `user`를 넣는다.
  4. `users`가 `temp`를 참조하도록 교체한다.
* 이유(핵심): Java 배열은 **크기 변경 불가능(immutable length)** → 크기를 늘리려면 새 배열 만들어 복사해야 함. 이 코드는 `ArrayList`가 내부적으로 하는 동작의 간단한 수동 구현.
* 성능: 매번 추가할 때마다 전체 배열을 새로 만들고 복사하므로, 요소가 많아지면 비용이 매우 커진다. (`O(n)` 복사)
* 대체: `ArrayList<User>`를 사용하면 내부에서 재할당을 더 효율적으로(증가폭 전략 등) 관리한다.

---

```java
    // 특정 이름을 넣고 조회하기
    public User findByUsername(String username) {

        // 향상된 for문으로 조회
        for (User user : users) {
            // user 엔티티에 있는 Username을 가져와서 (getter), 입력한 username과 일치하는지 보기
            if (user.getUsername().equals(username)) {
                // 그렇다면 DB 엔티티에 저장된 user를 반환
                return user;
            }
        }
        // 만약 조회되는 바가 없으면 null 반환처리
        return null;
    }
```

* 목적: `username`으로 `User` 하나를 검색해서 반환.
* 동작: 배열을 순회하면서 `user.getUsername().equals(username)`인 항목을 찾으면 그 `User`를 반환. 찾지 못하면 `null`.
* 주의/문제점:

  * `user.getUsername()` 또는 `username`이 `null`이면 `NullPointerException` 발생 가능. (안전하게 `username.equals(...)` 대신 `Objects.equals(a,b)` 또는 null 체크 사용)
  * `equals()`는 대소문자 구분한다. 필요에 따라 `equalsIgnoreCase()`를 고려.
  * 여러 사용자가 같은 username을 가질 수 있다면 첫 번째만 반환된다. 중복 허용/비허용 정책을 명확히 해야 한다.
  * 성능: 선형 검색 → 사용자 수 많아지면 느려짐. 빠른 조회가 필요하면 `Map<String, User>` 사용 권장.

---

# 요약 — 왜 배열을 쓰는가?

* 학습 목적: **배열의 동작 원리(고정 길이, 재할당 시 복사 등)**를 이해하기 위해 직접 구현하는 경우가 많다.
* 교육 효과: `ArrayList` 같은 추상화 뒤의 동작(복사, 재할당 전략)을 눈으로 직접 볼 수 있다.
* 실제 개발에선 보통 `ArrayList`, `HashMap`, DB를 사용한다. 수동 배열 관리는 실무에서 거의 직접 쓰지 않는다(예외적 성능 최적화 상황 제외).

---

# 추천 개선사항 (요약)

1. `users`를 `private`로 변경하고 필요한 getter만 제공.
2. `findAll()`은 원본 배열의 복사본을 반환하거나 불변(immutable) 컬렉션 반환.
3. `generatedUserId()`는 `nextId` 필드로 관리하거나 DB 시퀀스 사용.
4. `add()`는 `ArrayList<User>`로 대체.
5. `findByUsername()`는 `null` 안전성 검사 또는 `Map<String, User>`로 대체.
6. 동시성 필요하다면 동기화/Concurrent 컬렉션 고려.

---

# 바로 적용해볼 수 있는 리팩토링 (ArrayList 사용 예시)

아래 코드는 동일 기능을 `ArrayList`로 바꾼 버전이다. 장점: 코드가 간결하고 추가/복사 비용을 신경쓰지 않아도 된다.

```java
package com.korit.study.ch16_1.repository;

import com.korit.study.ch16_1.entity.User;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class UserList {
    // 내부 컬렉션은 private으로 감춘다
    private final List<User> users;
    private int nextId = 1; // 안전한 id 생성

    public UserList() {
        this.users = new ArrayList<>();
    }

    public List<User> findAll() {
        // 안전하게 복사본을 반환 (혹은 Collections.unmodifiableList(users))
        return new ArrayList<>(users);
    }

    public int generatedUserId() {
        return nextId++;
    }

    public void add(User user) {
        if (user == null) {
            throw new IllegalArgumentException("user cannot be null");
        }
        users.add(user);
    }

    public User findByUsername(String username) {
        if (username == null) {
            return null;
        }
        for (User user : users) {
            if (Objects.equals(user.getUsername(), username)) {
                return user;
            }
        }
        return null;
    }
}
```

* **장점**:

  * 코드가 짧고 읽기 쉽다.
  * `ArrayList`가 내부에서 확장/복사를 더 효율적으로 처리.
  * `nextId`로 id 충돌을 방지.
  * `users`가 `private final`이므로 외부에서 변경 불가.

---

원하면 다음 단계로:

* `Map<String, User>`를 사용해 `findByUsername`를 O(1)로 바꾸는 리팩토링도 보여줄게.
* 또는 네가 지금 사용 중인 `User` 엔티티(필드 구조)를 보여주면 `generatedUserId()`와 `add()`를 어떻게 안전하게 통합할지 더 정확히 도와줄게.

어떤 걸 먼저 해볼까? ArrayList 버전으로 프로젝트에 적용해볼래?

    *
    * */
